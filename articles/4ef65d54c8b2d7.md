---
title: "Rustã§AtCoderã«æŒ‘æˆ¦ã—ã¦ã¿ã¦æ°—ã¥ã„ãŸãƒã‚¤ãƒ³ãƒˆã¾ã¨ã‚"
emoji: "ğŸ“’"
type: "tech"
topics:
  - "rust"
  - "atcoder"
published: true
published_at: "2021-06-13 15:33"
---

æ…£ã‚Œã¦ã„ãªã„ã¨Rustã§ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãŒé »ç™ºã—ã¾ã™ã€‚AtCoderã®ç°¡å˜ãªå•é¡Œã«è§¦ã‚Œã‚‹ã“ã¨ã§ã€ã¤ã¾ã¥ããŒã¡ãªã¨ã“ã‚ã‚’ã¾ã¨ã‚ã¦ã„ããŸã„ã¨æ€ã„ã¾ã™ã€‚

ï¼ˆéšæ™‚æ›´æ–°ã—ã¦ã„ãã¾ã™ï¼‰

## æŒ‘æˆ¦ã—ãŸå•é¡Œ
- ABC
  - ABC195 ~ ABC204ã®ç°è‰²ã€èŒ¶è‰²

## input

### çœç•¥å¯èƒ½ãªé…åˆ—ã‚µã‚¤ã‚º

ã“ã®ã‚ˆã†ã«å—ã‘å–ã‚‹ã‚‚ã®ã¯
```rust
    input! {
        n: usize,
        arr: [usize; n],
    }
```

ä¸‹ã®ã‚ˆã†ã«çœç•¥ã§ãã‚‹ã€‚
```rust
    input! {
        arr: [usize],
    }
```
ãŸã ã—ã€ãªã‚“ã ã‹ã‚“ã  `n` ãŒå¿…è¦ãªå ´é¢ã¯å¤šã„ã®ã§çœç•¥ã—ãªã„å½¢ã§æ›¸ã„ãŸæ–¹ãŒè‰¯ã•ãã†ã€‚

### æ–‡å­—åˆ—ã‚’ã¯ã˜ã‚ã‹ã‚‰Vec\<char\>ã«ã—ã¦ãŠã

```rust
use proconio::{input, marker::Chars};
 
fn main() {
    input! {
        s: Chars,
    }
```

## å‹

### å‹æ¨è«–ã§i32ã«ãªã£ã¦ã—ã¾ã†ã“ã¨ã«æ³¨æ„

å•é¡Œä¾‹: 
https://atcoder.jp/contests/abc200/tasks/abc200_c

ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§ `vec` ã®å‹ã‚’çœç•¥ã—ã¦ã—ã¾ã†ã¨ã€i32ã§æ¨è«–ã•ã‚Œã¦ã—ã¾ã†ã€‚ãã®çµæœ `a * (a - 1) / 2` ã®ã¨ã“ã‚ã§èª¤ã£ãŸç­”ãˆã«ãªã£ã¦ã—ã¾ã†ã€‚ï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã§ã¯ãªãè¨ˆç®—çµæœã«èª¤ã‚ŠãŒç”Ÿã˜ã‚‹ï¼‰
```rust
use proconio::input;
 
fn main() {
    input! {
        n: usize,
        arr: [usize; n],
    }
    let mut vec: Vec<i64> = vec![0; 200usize];
    for a in &arr {
        vec[ a % 200 ] += 1;
    }
    let mut ans: i64 = 0;
    for a in &vec {
        ans += a * (a - 1) / 2;
    }
    println!("{}", ans);
}
```

### usizeã§å¼•ãç®—ã™ã‚‹ã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã¨ããŒã‚ã‚‹

å•é¡Œä¾‹: https://atcoder.jp/contests/abc203/tasks/abc203_c

ä¸‹ã®ã‚³ãƒ¼ãƒ‰ã§æ¨™æº–å…¥åŠ›ã‚’`usize`ã§å—ã‘å–ã‚‹ã¨ã‚ªãƒ¼ãƒãƒ¼ãƒ•ãƒ­ãƒ¼ãŒç™ºç”Ÿã™ã‚‹ã¨ããŒã‚ã‚‹ã€‚
```rust
use proconio::input;
 
fn main() {
    input! {
        n: isize,
        k: isize,
        mut arr: [(isize, isize); n],
    }
    arr.sort_by_key(|k| k.0);
    let mut ans = 0;
    let mut money = k;
    for &(a, b) in &arr {
        if a - ans > money {
            ans += money;
            money = 0;
            break;
        } else {
            money += b - (a - ans);
            ans = a;
        }
    }
    if money > 0 {
        ans += money;
    }
    println!("{}", ans);
}

```

## å¤‰æ•°

### å¤‰æ•°ã®å…¥ã‚Œæ›¿ãˆ

```rust
// ã‚ã‚‰ã‹ã˜ã‚ use std::mem::swap; ã—ã¦ãŠãã“ã¨
// x,y = y,x ã®ã‚ˆã†ãªã“ã¨ãŒã§ãã‚‹
swap(&mut x, &mut y);
```

## è¨ˆç®—

### f64ã§ã®ç´¯ä¹—

`pow()` ã§ã¯ãªã `powi()` ã‚’ä½¿ã†ã€‚æŒ‡æ•°éƒ¨åˆ†ã‚‚f64ã®å ´åˆã¯ `powf()` ã‚’ä½¿ã†ã€‚

### åˆ‡ã‚Šä¸Šã’/åˆ‡ã‚Šæ¨ã¦

åˆ‡ã‚Šä¸Šã’ã¯`ceil()`ã§åˆ‡ã‚Šæ¨ã¦ã¯`floor()`ã€‚

å››æ¨äº”å…¥ã¯ä½¿ã†æ©Ÿä¼šã‚ã¾ã‚Šç„¡ã„ã¨æ€ã†ã‘ã© `round()`ã€‚

## ãƒ«ãƒ¼ãƒ—

### é™é †ã®é€£ç•ªãƒ«ãƒ¼ãƒ—

`for i in (0..n).rev()` ã§ n - 1, n - 2, ... 0 ã®ãƒ«ãƒ¼ãƒ—ã«ãªã‚‹ã€‚

### ç„¡é™ãƒ«ãƒ¼ãƒ—

```rust
loop {
  // ç„¡é™ãƒ«ãƒ¼ãƒ—. while true {}ã®ä»£ã‚ã‚Šã«ä½¿ãˆã‚‹
}
```

## é…åˆ—

### sort()ã¯ç ´å£Šçš„ãƒ¡ã‚½ãƒƒãƒ‰

`arr = arr.sort();` ã®ã‚ˆã†ãªã“ã¨ã‚’ã™ã‚‹ã®ã§ã¯ãªãã€å˜ã« `arr.sort();` ã‚’ã‚„ã‚Œã°è‰¯ã„ã€‚

### sort_by_key()ã§ã‚½ãƒ¼ãƒˆã®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã‚’æŒ‡å®šã§ãã‚‹

```rust
    input! {
        n: usize,
        mut arr: [(String, i64); n],
    }
    arr.sort_by_key(|k| k.1); // -k.1ã¨ã™ã‚Œã°é™é †
```

### å’Œã‚’å–ã‚‹

```rust
    arr.iter().sum();
```

### min/maxã‚’å–ã‚‹

```rust
    let a = arr.iter().min();
    let b = arr.iter().max();
    // å€¤ã‚’ä½¿ã£ã¦è¨ˆç®—ã™ã‚‹ãŸã‚ã«ã¯unwrap()ãŒå¿…è¦
    a.unwrap() + b.unwrap();
```

## Set
### Setã®åŸºæœ¬çš„ãªä½¿ã„æ–¹

ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ: https://doc.rust-lang.org/std/collections/struct.HashSet.html

```rust
use std::collections::HashSet;
 
fn main() {
    let mut set = HashSet::new();
    set.insert(1);
    for a in &set {
      // é…åˆ—ã‚„ãƒ™ã‚¯ã‚¿ã®ã‚ˆã†ã«foræ–‡ã‚’å›ã›ã‚‹
    }
    set.contains(&1);
}
```

## æ–‡å­—åˆ— (String, Vec\<char\>)

### Stringâ†’Vec\<char\>ã®å¤‰æ›

```rust
    input! {
        s: String,
    }
    let c: Vec<char> = s.chars().collect();
```

### Vec\<char\>â†’Stringã®å¤‰æ›

```rust
    c.iter().collect::<String>();
    // é€†é †ã«ã‚‚ã§ãã‚‹
    c.iter().rev().collect::<String>();
```

### Stringâ†’æ•°å€¤ã®å¤‰æ›
```rust
// å‹ã®æŒ‡å®šãŒå¿…è¦
let num = s.parse::<i64>().unwrap();

// å¤‰æ•°éƒ¨åˆ†ã«æŒ‡å®šã—ã¦ã‚‚OK
let num: i64 = s.parse::().unwrap();
```

### æ–‡å­—ã®å…¥ã‚Œæ›¿ãˆ

```rust
// ã‚ã‚‰ã‹ã˜ã‚ use std::mem::swap; ã—ã¦ãŠãã“ã¨

    let mut s1: Vec<char> = s[..n].to_vec();
    let mut s2: Vec<char> = s[n..].to_vec();

    // å¤‰æ•°å†…ã§æ–‡å­—ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
    s1.swap(0, 1);

    // å¤‰æ•°é–“ã§æ–‡å­—ã‚’å…¥ã‚Œæ›¿ãˆã‚‹
    swap(&mut s1[0], &mut s2[1]);
}
```

### æ–‡å­—åˆ—çµåˆ

`String` + `&str` ã®å½¢ã§ã‚ã‚Œã°ã§ãã‚‹ã€‚

### æŒ¿å…¥

Vec\<Char\>é™å®šã§ `insert` ã¨ã„ã†ãƒ¡ã‚½ãƒƒãƒ‰ã§å¥½ããªä½ç½®ã«æ–‡å­—ã‚’å…¥ã‚Œã‚‹ã“ã¨ãŒã§ãã‚‹ã€‚
```rust
# å…ˆé ­ã«'0'ã‚’è¿½åŠ 
s.insert(0, '0');
```

## DFS

### å†å¸°ã¨whileã«ã‚ˆã‚‹å®Ÿè£…

å•é¡Œä¾‹: https://atcoder.jp/contests/abc204/tasks/abc204_c

#### å†å¸°
```rust
use proconio::input;
 
fn main() {
    input! {
        n: usize,
        m: usize,
        arr: [(usize, usize); m],
    }
    let mut graph = vec![vec![]; n + 1];
    for i in 0..m {
        let (a, b) = arr[i];
        graph[a].push(b);
    }

    let mut ans = 0;
    for i in 1..=n {
        let mut tmp = vec![false; n+1];
        dfs(&graph, &mut tmp, i);
        for b in &tmp {
            if *b {
                ans += 1;
            }
        }
    }
    println!("{}", ans);
}

fn dfs(graph: &Vec<Vec<usize>>, tmp: &mut Vec<bool>, i: usize) {
    if tmp[i] {
        return;
    } else {
        tmp[i] = true;
        for j in &graph[i] {
            dfs(graph, tmp, *j);
        }
    }
}
```

#### while

VecDequeã‚’ä½¿ã†ã€‚ã“ã®å•é¡Œã¯BFSã§ã‚‚è§£ã‘ã‚‹ï¼ˆVecDequeã‚’Vecã«ã—ã¦push(), pop()ã™ã‚Œã°è‰¯ã„ï¼‰
```rust
use proconio::input;
use std::collections::VecDeque;
 
fn main() {
    input! {
        n: usize,
        m: usize,
        arr: [(usize, usize); m],
    }
    let mut graph = vec![vec![]; n + 1];
    for i in 0..m {
        let (a, b) = arr[i];
        graph[a].push(b);
    }

    let mut ans = 0;
    for i in 1..=n {
        let mut tmp = vec![false; n+1];
        let mut tmp2 = VecDeque::new();
        tmp2.push_back(i);
        while tmp2.len() > 0 {
            let x = tmp2.pop_front().unwrap();
            tmp[x] = true;
            for y in &graph[x] {
                if !tmp[*y] {
                    tmp2.push_back(*y);
                }
            }
        }
        for b in &tmp {
            if *b {
                ans += 1;
            }
        }
    }

    println!("{}", ans);
}
```